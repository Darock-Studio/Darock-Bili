//
//   Generated by https://github.com/blacktop/ipsw (Version: 3.1.454, BuildTime: 2024-02-08T22:07:34Z)
//
//    - LC_BUILD_VERSION:  Platform: watchOSSimulator, MinOS: 10.2, SDK: 10.2, Tool: ld (902.8)
//    - LC_SOURCE_VERSION: 445.201.0.0.0
//
#ifndef CHTokenizedTextResult_h
#define CHTokenizedTextResult_h
@import Foundation;

#include "NSCopying-Protocol.h"
#include "NSMutableCopying-Protocol.h"
#include "NSSecureCoding-Protocol.h"

@class NSArray, NSIndexSet, NSString;

@interface CHTokenizedTextResult : NSObject<NSCopying, NSMutableCopying, NSSecureCoding> {
  /* instance variables */
  NSArray *_tokenColumns;
  long long _recognizerGenerationIdentifier;
  long long _precedingLineBreaks;
  long long _changeableCount;
}

@property (readonly, nonatomic) long long tokenColumnCount;
@property (readonly, nonatomic) long long changeableTokenColumnCount;
@property (readonly, copy, nonatomic) NSString *trailingSeparator;
@property (readonly, nonatomic) NSIndexSet *strokeIndexes;
@property (readonly, nonatomic) BOOL isMinimalDrawingResult;
@property (readonly, nonatomic) int baseWritingDirection;
@property (readonly, copy, nonatomic) NSArray *transcriptionPaths;
@property (readonly, copy, nonatomic) NSArray *transcriptionPathScores;
@property (readonly, copy, nonatomic) NSString *topTranscription;
@property (readonly, copy, nonatomic) NSString *rawTranscription;
@property (readonly, nonatomic) NSString *recognizerDebugDescription;

/* class methods */
+ (BOOL)supportsSecureCoding;
+ (id)resultRestoringRawPathInResult:(id)result;
+ (id)loadFromFile:(id)file;
+ (id)tokenizedTextResultWithString:(id)string strokeIndexes:(id)indexes bounds:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })bounds trailingSeparator:(id)separator recognizerGenerationIdentifier:(long long)identifier;
+ (BOOL)areTokenRowsEquivalent:(id)equivalent otherRow:(id)row;
+ (long long)mergeTokenRow:(id)row intoUniqueRows:(id)rows;
+ (id)extendedToken:(id)token withStrokeIndexSet:(id)set alignmentScore:(double)score bounds:(struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; })bounds;
+ (id)tokenizedTextResultFromResults:(id)results shouldPerformStrictFiltering:(BOOL)filtering doesTopLocaleRequireSpecialHandling:(BOOL)handling hasSwap:(BOOL)swap;
+ (id)swappableColumnIndexesInResults:(id)results locales:(id)locales topLocaleIndex:(long long)index swappableIndex:(long long)index shouldReverseSwappableColumns:(BOOL)columns;
+ (id)compressResult:(id)result atColumnIndexes:(id)indexes;
+ (id)resultsBySwapping:(id)swapping swappableColumns:(id)columns locales:(id)locales topLocaleIndex:(long long)index topLocale:(id)locale;

/* instance methods */
- (id)init;
- (id)initWithTokenColumns:(id)columns transcriptionPaths:(id)paths scores:(id)scores trailingSeparator:(id)separator recognizerGenerationIdentifier:(long long)identifier changeableColumnCount:(long long)count isMinimalDrawingResult:(BOOL)result baseWritingDirection:(int)direction;
- (id)initWithTokenColumns:(id)columns transcriptionPaths:(id)paths scores:(id)scores trailingSeparator:(id)separator recognizerGenerationIdentifier:(long long)identifier changeableColumnCount:(long long)count;
- (id)initWithTokenColumns:(id)columns transcriptionPaths:(id)paths scores:(id)scores trailingSeparator:(id)separator recognizerGenerationIdentifier:(long long)identifier;
- (id)initWithTokenColumns:(id)columns transcriptionPaths:(id)paths scores:(id)scores recognizerGenerationIdentifier:(long long)identifier;
- (id)initWithTokenColumns:(id)columns transcriptionPaths:(id)paths scores:(id)scores recognizerGenerationIdentifier:(long long)identifier isMinimalDrawingResult:(BOOL)result baseWritingDirection:(int)direction;
- (id)initWithBestPathTokens:(id)tokens pathProbabilities:(id)probabilities trailingSeparator:(id)separator recognizerGenerationIdentifier:(long long)identifier;
- (id)initWithBestPathTokens:(id)tokens pathProbabilities:(id)probabilities trailingSeparator:(id)separator recognizerGenerationIdentifier:(long long)identifier changeableColumnCount:(long long)count;
- (id)modifiedResultWithBestPathTokens:(id)tokens pathProbabilities:(id)probabilities;
- (id)initWithCoder:(id)coder;
- (void)encodeWithCoder:(id)coder;
- (id)copyWithZone:(struct _NSZone *)zone;
- (id)mutableCopyWithZone:(struct _NSZone *)zone;
- (id)description;
- (id)tokenColumns;
- (id)tokenRowsAtColumnIndex:(long long)index;
- (id)tokensInTranscriptionPath:(id)path atColumnIndex:(long long)index;
- (id)tokenAtLocation:(struct { long long x0; long long x1; long long x2; })location;
- (long long)recognizerGenerationIdentifier;
- (long long)precedingLineBreaks;
- (double)heuristicTextScoreForColumnRange:(struct _NSRange { unsigned long long x0; unsigned long long x1; })range;
- (double)averageTokenRecognitionScoreForColumnRange:(struct _NSRange { unsigned long long x0; unsigned long long x1; })range;
- (BOOL)hasTextReplacementsInColumnRange:(struct _NSRange { unsigned long long x0; unsigned long long x1; })range;
- (id)transcriptionWithPath:(id)path columnRange:(struct _NSRange { unsigned long long x0; unsigned long long x1; })range filterLowConfidence:(BOOL)confidence;
- (id)transcriptionWithPath:(id)path columnRange:(struct _NSRange { unsigned long long x0; unsigned long long x1; })range filterLowConfidence:(BOOL)confidence allowPrecedingSeparator:(BOOL)separator;
- (id)transcriptionWithPath:(id)path columnRange:(struct _NSRange { unsigned long long x0; unsigned long long x1; })range filterLowConfidence:(BOOL)confidence excludeGibberish:(BOOL)gibberish rejectionRate:(double *)rate tokenProcessingBlock:(id /* block */)block;
- (id)transcriptionWithPath:(id)path columnRange:(struct _NSRange { unsigned long long x0; unsigned long long x1; })range filterLowConfidence:(BOOL)confidence excludeGibberish:(BOOL)gibberish allowPrecedingSeparator:(BOOL)separator rejectionRate:(double *)rate tokenProcessingBlock:(id /* block */)block;
- (BOOL)shouldFilterOutStringForToken:(id)token isGibberish:(BOOL *)gibberish;
- (BOOL)isPathOriginal:(id)original;
- (id)precedingSeparatorForTopTranscriptionPath;
- (id)precedingSeparatorForRawTranscriptionPath;
- (id)precedingSeparatorForToken:(id)token;
- (id)strokeIndexesForColumnsInRange:(struct _NSRange { unsigned long long x0; unsigned long long x1; })range;
- (id)strokeIndexSetsInPath:(id)path columnRange:(struct _NSRange { unsigned long long x0; unsigned long long x1; })range;
- (BOOL)isValid;
- (id)tokensFromTopTranscriptionWithCharacterRange:(struct _NSRange { unsigned long long x0; unsigned long long x1; })range;
- (id)tokenizedResultWithFilteredPaths:(double)paths;
- (struct { double x0; double x1; })languageFitnessForLocale:(id)locale recognitionMode:(int)mode;
- (id)lastTokenStrokeIndexes;
- (id)textRecognitionResultArrayGivenHistory:(id)history;
- (id)textRecognitionResultArray;
- (void)enumerateTokensInTopTranscriptionPathWithBlock:(id /* block */)block;
- (void)enumerateTokensInTranscriptionPath:(id)path columnRange:(struct _NSRange { unsigned long long x0; unsigned long long x1; })range tokenProcessingBlock:(id /* block */)block;
- (BOOL)isEqualToTokenizedTextResult:(id)result;
- (BOOL)isEqual:(id)equal;
- (unsigned long long)hash;
- (id)writeToFile;
- (id)writeToFileInFolder:(id)folder basename:(id)basename;
- (id)phraseCaseCorrectedResultWithHistory:(id)history phraseLexicon:(struct _LXLexicon *)lexicon maxPhraseLength:(long long)length;
- (id)changeableColumnCountUpdatedResultWithHistory:(id)history phraseLexicon:(struct _LXLexicon *)lexicon maxPhraseLength:(long long)length;
- (id)subResultWithColumnRange:(struct _NSRange { unsigned long long x0; unsigned long long x1; })range;
- (id)commonTopStrokeSetsWithResult:(id)result shouldReverseOtherColumns:(BOOL)columns;
@end

#endif /* CHTokenizedTextResult_h */
