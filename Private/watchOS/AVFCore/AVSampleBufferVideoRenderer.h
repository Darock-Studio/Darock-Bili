//
//   Generated by https://github.com/blacktop/ipsw (Version: 3.1.454, BuildTime: 2024-02-08T22:07:34Z)
//
//    - LC_BUILD_VERSION:  Platform: watchOSSimulator, MinOS: 10.2, SDK: 10.2, Tool: ld (902.8)
//    - LC_SOURCE_VERSION: 2220.14.1.0.0
//
#ifndef AVSampleBufferVideoRenderer_h
#define AVSampleBufferVideoRenderer_h
@import Foundation;

#include "AVApplicationStateMonitor.h"
#include "AVContentKeySession.h"
#include "AVFigVideoQueueFactory-Protocol.h"
#include "AVMediaDataRequester.h"
#include "AVMediaDataRequesterConsumer-Protocol.h"
#include "AVQueuedSampleBufferRendering-Protocol.h"
#include "AVQueuedSampleBufferRenderingInternal-Protocol.h"
#include "AVSampleBufferDisplayLayer.h"
#include "AVSampleBufferRenderSynchronizer.h"

@class NSArray, NSError, NSMutableArray, NSString;
@protocol OS_dispatch_queue;

@interface AVSampleBufferVideoRenderer : NSObject<AVMediaDataRequesterConsumer, AVFigVideoQueueFactory, AVQueuedSampleBufferRenderingInternal, AVQueuedSampleBufferRendering> {
  /* instance variables */
  struct OpaqueFigVideoQueue * _videoQueue;
  BOOL _outputObscured;
  AVSampleBufferDisplayLayer *_weakDisplayLayer;
  BOOL _containsDisplayLayer;
  struct __CFArray * _figVideoTargets;
  struct CGRect { struct CGPoint { double x; double y; } origin; struct CGSize { double width; double height; } size; } _previousSourceRect;
  AVApplicationStateMonitor *_applicationStateMonitor;
  BOOL _hasEverEnqueued;
  BOOL _isRequestingMediaData;
  AVMediaDataRequester *_mediaDataRequester;
  BOOL _aboveHighWaterLevel;
  BOOL _createVideoQueueFailed;
  NSObject<OS_dispatch_queue> *_serialQueue;
  NSObject<OS_dispatch_queue> *_videoQueueQueue;
  NSObject<OS_dispatch_queue> *_layerQueue;
  AVSampleBufferRenderSynchronizer *_weakReferenceToSynchronizer;
  BOOL _addedToSynchronizer;
  BOOL _controlTimebaseSetByUserIsInUse;
  struct OpaqueCMTimebase * _controlTimebaseSetByUser;
  struct OpaqueCMTimebase * _readOnlyVideoQueueTimebase;
  struct OpaqueCMTimebase * _readOnlyRenderingTimebase;
  NSMutableArray *_videoOutputs;
  NSObject<OS_dispatch_queue> *_flushCallbackListQueue;
  NSObject<OS_dispatch_queue> *_flushCallbackQueue;
  NSMutableArray *_flushCallbacks;
  NSObject<OS_dispatch_queue> *_queueForProtectingPrerollCompleteCallback;
  id /* block */ _pendingPrerollCompleteCallback;
  int _pendingPrerollRequestID;
  NSObject<OS_dispatch_queue> *_queueForCallingPrerollCompleteCallback;
  int _upcomingPTSExpectation;
  struct { long long value; int timescale; unsigned int flags; long long epoch; } _minimumUpcomingPTS;
  AVContentKeySession *_weakContentKeySession;
  struct opaqueCMFormatDescription * _lastFormatDescription;
  struct OpaqueFigCPECryptor * _lastCryptor;
  id _didFinishSuspensionNotificationToken;
}

@property (readonly) BOOL outputObscuredDueToInsufficientExternalProtection;
@property (nonatomic) BOOL preventsCapture;
@property (nonatomic) BOOL preventsDisplaySleepDuringVideoPlayback;
@property (nonatomic) BOOL preventsAutomaticBackgroundingDuringVideoPlayback;
@property BOOL disallowsVideoLayerDisplayCompositing;
@property (readonly, nonatomic) NSArray *outputs;
@property (copy, nonatomic) NSString *STSLabel;
@property (readonly) long long status;
@property (readonly) NSError *error;
@property (readonly) BOOL requiresFlushToResumeDecoding;
@property (readonly) unsigned long long hash;
@property (readonly) Class superclass;
@property (readonly, copy) NSString *description;
@property (readonly, copy) NSString *debugDescription;
@property (readonly, retain) struct OpaqueCMTimebase * timebase;
@property (readonly) BOOL readyForMoreMediaData;
@property (readonly, nonatomic) BOOL hasSufficientMediaDataForReliablePlaybackStart;

/* class methods */
+ (void)initialize;
+ (BOOL)automaticallyNotifiesObserversForKey:(id)key;

/* instance methods */
- (void)_updateVideoOutputs;
- (void)addOutput:(id)output;
- (void)removeOutput:(id)output;
- (struct __CVBuffer *)copyDisplayedPixelBuffer;
- (BOOL)_setUpcomingPresentationTimeExpectations:(int)expectations minimumPresentationTime:(struct { long long x0; int x1; unsigned int x2; long long x3; })time;
- (void)expectMinimumUpcomingSampleBufferPresentationTime:(struct { long long x0; int x1; unsigned int x2; long long x3; })time;
- (void)expectMonotonicallyIncreasingUpcomingSampleBufferPresentationTimes;
- (void)resetUpcomingSampleBufferPresentationTimeExpectations;
- (void)_setDisallowsVideoLayerDisplayCompositing:(BOOL)compositing;
- (BOOL)_disallowsVideoLayerDisplayCompositing;
- (void)setControlTimebase:(struct OpaqueCMTimebase *)timebase;
- (BOOL)_setSynchronizerTimebase:(struct OpaqueCMTimebase *)timebase error:(id *)error;
- (struct OpaqueCMTimebase *)_readOnlyVideoQueueTimebase;
- (int)_initializeTimebases;
- (int)_createVideoQueue:(struct OpaqueFigVideoQueue * *)queue errorStep:(id *)step;
- (BOOL)_isCreateVideoQueueErrorRetryable:(int)retryable;
- (int)createVideoQueue:(struct OpaqueFigVideoQueue * *)queue;
- (struct OpaqueFigVideoQueue *)_copyVideoQueue;
- (BOOL)_hasEverEnqueued;
- (void)_refreshAboveHighWaterLevel;
- (void)_setStatus:(long long)status error:(id)error;
- (void)_resetStatusWithOSStatus:(int)osstatus;
- (void)_setOutputObscuredDueToInsufficientExternalProtection:(BOOL)protection;
- (id)currentFigVideoQueueFactory;
- (void)_addFigVideoQueueListeners;
- (void)_removeFigVideoQueueListeners;
- (void)_setRequiresFlushToResumeDecoding:(BOOL)decoding;
- (void)_setCreateVideoQueueFailedWithOSStatus:(int)osstatus;
- (BOOL)_createVideoQueueFailed;
- (id)init;
- (void)dealloc;
- (struct OpaqueCMTimebase *)controlTimebase;
- (void)setDisplayLayerVisibility:(BOOL)visibility;
- (BOOL)setRenderSynchronizer:(id)synchronizer error:(id *)error;
- (void)copyFigSampleBufferAudioRenderer:(struct OpaqueFigSampleBufferAudioRenderer * *)renderer;
- (void)setToneMapToStandardDynamicRange:(BOOL)range;
- (void)setContentKeySession:(id)session;
- (int)attachToContentKeySession:(id)session contentKeyBoss:(struct CMBaseObject *)boss failedSinceAlreadyAttachedToAnotherSession:(BOOL *)session;
- (BOOL)attachedToExternalContentKeySession;
- (id)contentKeySession;
- (BOOL)isReadyForMoreMediaData;
- (id)_statusString:(long long)string;
- (int)_enqueueSingleSampleBuffer:(struct opaqueCMSampleBuffer *)buffer bufferEnqueueingInfo:(struct { struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; } x0; struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; } x1; } *)info;
- (struct { struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; } x0; struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; } x1; })_computeSampleBufferEnqueueingInfoForSampleBuffer:(struct opaqueCMSampleBuffer *)buffer;
- (void)enqueueSampleBuffer:(struct opaqueCMSampleBuffer *)buffer;
- (void)enqueueSampleBuffer:(struct opaqueCMSampleBuffer *)buffer bufferEnqueueingInfo:(struct { struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; } x0; struct CGRect { struct CGPoint { double x0; double x1; } x0; struct CGSize { double x0; double x1; } x1; } x1; } *)info;
- (void)flush;
- (void)flushAndRemoveImage;
- (void)flushWithRemovalOfDisplayedImage:(BOOL)image completionHandler:(id /* block */)handler;
- (void)_flushComplete;
- (void)_callOldPrerollCompletionHandlerWithSuccess:(BOOL)success andSetNewPrerollCompletionHandler:(id /* block */)handler forRequestID:(int)id;
- (void)_completedDecodeForPrerollForRequestID:(int)id;
- (void)prerollDecodeWithCompletionHandler:(id /* block */)handler;
- (void)requestMediaDataWhenReadyOnQueue:(id)queue usingBlock:(id /* block */)block;
- (void)stopRequestingMediaData;
- (void)addSampleBufferDisplayLayer:(id)layer;
- (void)_updateVideoTargetsOnVideoQueue;
- (void)addVideoTarget:(struct OpaqueFigVideoTarget *)target;
- (int)_setContentLayerOnFigVideoQueue:(struct OpaqueFigVideoQueue *)queue;
- (void)_didFinishSuspension:(id)suspension;
@end

#endif /* AVSampleBufferVideoRenderer_h */
