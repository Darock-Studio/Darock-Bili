//
//   Generated by https://github.com/blacktop/ipsw (Version: 3.1.454, BuildTime: 2024-02-08T22:07:34Z)
//
//    - LC_BUILD_VERSION:  Platform: watchOSSimulator, MinOS: 10.2, SDK: 10.2, Tool: ld (902.8)
//    - LC_SOURCE_VERSION: 1899.42.9.28.10
//
#ifndef VKRouteLine_h
#define VKRouteLine_h
@import Foundation;

#include "VKPolylineOverlay.h"
#include "VKPolylineOverlayRenderRegion.h"
#include "VKRouteLineObserverProtocol-Protocol.h"

@class GEOComposedRoute, GEOPathMatcher, NSArray, NSMutableArray, NSSet;
@protocol struct Box<double, 3> { struct Matrix<double, 3, 1> { double x0[3] } x0; struct Matrix<double, 3, 1> { double x0[3] } x1; }, struct vector<geo::fast_shared_ptr<md::RouteLineSection, mdm::MDAllocator>, std::allocator<geo::fast_shared_ptr<md::RouteLineSection, mdm::MDAllocator>>> { void * x0; void * x1; struct __compressed_pair<geo::fast_shared_ptr<md::RouteLineSection, mdm::MDAllocator> *, std::allocator<geo::fast_shared_ptr<md::RouteLineSection, mdm::MDAllocator>>> { void * x0; } x2; }, {Box<double, 3>="_minimum"{Matrix<double, 3, 1>="_e"[3d]}"_maximum"{Matrix<double, 3, 1>="_e"[3d]}}, {ManeuverArrowCoordinates="_maneuverArrows"{vector<md::ManeuverArrowInfo, std::allocator<md::ManeuverArrowInfo>>="__begin_"^{ManeuverArrowInfo}"__end_"^{ManeuverArrowInfo}"__end_cap_"{__compressed_pair<md::ManeuverArrowInfo *, std::allocator<md::ManeuverArrowInfo>>="__value_"^{ManeuverArrowInfo}}}}, {Matrix<double, 4, 4>="_e"[16d]}, {Matrix<float, 2, 1>="_e"[2f]}, {_retain_ptr<NSUUID *, geo::_retain_objc_arc, geo::_release_objc_arc, geo::_hash_objc, geo::_equal_objc>="_vptr$_retain_ptr"^^?"_obj"@"NSUUID""_retain"{_retain_objc_arc=}"_release"{_release_objc_arc=}}, {fast_shared_ptr<md::RouteLineSection, mdm::MDAllocator>="_control"^{_fast_shared_ptr_control}}, {vector<geo::fast_shared_ptr<md::RouteLineSection, mdm::MDAllocator>, std::allocator<geo::fast_shared_ptr<md::RouteLineSection, mdm::MDAllocator>>>="__begin_"^v"__end_"^v"__end_cap_"{__compressed_pair<geo::fast_shared_ptr<md::RouteLineSection, mdm::MDAllocator> *, std::allocator<geo::fast_shared_ptr<md::RouteLineSection, mdm::MDAllocator>>>="__value_"^v}};

@interface VKRouteLine : NSObject {
  /* instance variables */
  BOOL _matchToRoads;
  struct Matrix<double, 4, 4> { double x[16] _e; } _inverseMatrix;
  double _boundsUnitsPerMeter;
  double _metersPerPoint;
  double _viewUnitsPerPoint;
  struct fast_shared_ptr<md::RouteLineSection, mdm::MDAllocator> { struct _fast_shared_ptr_control *_control; } _userLocationSection;
  struct PolylineCoordinate { unsigned int index; float offset; } _userLocationIndex;
  struct Matrix<float, 2, 1> { float x[2] _e; } _userLocation;
  struct _retain_ptr<NSUUID *, geo::_retain_objc_arc, geo::_release_objc_arc, geo::_hash_objc, geo::_equal_objc> { undefined * *_vptr$_retain_ptr; NSUUID *_obj; struct _retain_objc_arc _retain; struct _release_objc_arc _release; } _revisionIdentifier;
  double _lastTrafficTimeStamp;
  NSSet *_retainedMatchedSegment;
  struct ManeuverArrowCoordinates { struct vector<md::ManeuverArrowInfo, std::allocator<md::ManeuverArrowInfo>> { struct ManeuverArrowInfo *__begin_; struct ManeuverArrowInfo *__end_; struct __compressed_pair<md::ManeuverArrowInfo *, std::allocator<md::ManeuverArrowInfo>> { struct ManeuverArrowInfo *__value_; } __end_cap_; } _maneuverArrows; } _maneuverArrowCoordinates;
  double _builtViewUnitsPerPoint;
  NSMutableArray *_pendingMatchedSegments;
  struct mutex { struct _opaque_pthread_mutex_t { long long __sig; char x[56] __opaque; } __m_; } _matchedSegmentsLock;
}

@property BOOL hasNewRoadMatches;
@property (readonly, nonatomic) struct vector<geo::fast_shared_ptr<md::RouteLineSection, mdm::MDAllocator>, std::allocator<geo::fast_shared_ptr<md::RouteLineSection, mdm::MDAllocator>>> { void * x0; void * x1; struct __compressed_pair<geo::fast_shared_ptr<md::RouteLineSection, mdm::MDAllocator> *, std::allocator<geo::fast_shared_ptr<md::RouteLineSection, mdm::MDAllocator>>> { void * x0; } x2; } sections;
@property (readonly, nonatomic) struct Box<double, 3> { struct Matrix<double, 3, 1> { double x0[3] } x0; struct Matrix<double, 3, 1> { double x0[3] } x1; } bounds;
@property (readonly, nonatomic) VKPolylineOverlayRenderRegion *renderRegion;
@property (readonly, nonatomic) double boundsInWorldUnit;
@property (readonly, nonatomic) VKPolylineOverlay *overlay;
@property (readonly, nonatomic) GEOComposedRoute *composedRoute;
@property (weak, nonatomic) NSObject<VKRouteLineObserverProtocol> *observer;
@property (readonly, nonatomic) GEOPathMatcher *pathMatcher;
@property unsigned short numPathsMatching;
@property (readonly, nonatomic) NSArray *matchedSegments;
@property (nonatomic) unsigned int matchingStartIndex;
@property (nonatomic) unsigned int matchingEndIndex;
@property (nonatomic) double simplificationEpsilonPoints;

/* instance methods */
- (id)initWithPolylineOverlay:(id)overlay;
- (void)dealloc;
- (void)_addMatchedSegments:(id)segments;
- (void)_clearMatchedSegments;
- (void)_updateTilesCovered:(id)covered;
- (BOOL)buildRouteLine:(id)line matchToRoads:(BOOL)roads shouldGenerateSnapPath:(BOOL)path viewUnitsPerPoint:(double)point force:(BOOL)force boundsInflation:(float)inflation isGradientTraffic:(BOOL)traffic currentLegIndex:(unsigned int)index;
- (void)generateArrowsForManeuverDisplayMode:(int)mode routeLineWidth:(double)width;
- (void)createMeshIfNecessary:(long long)necessary;
- (BOOL)isTrafficUpToDate;
- (BOOL)isTrafficUptoDate:(double)date;
- (BOOL)needsUpdateForViewingScale:(double)scale;
- (struct optional<VKRouteLineSnapResult> { union { char x0; struct VKRouteLineSnapResult { struct Mercator3<double> { double x0[3] } x0; struct pair<geo::Mercator3<double>, geo::Mercator3<double>> { struct Mercator3<double> { double x0[3] } x0; struct Mercator3<double> { double x0[3] } x1; } x1; } x1; } x0; BOOL x1; })snapRouteMatch:(id)match;
- (void)splitRouteLineAtAnnotation:(id)annotation;
- (void)forEachSection:(id /* block */)section;
- (void)_updateBounds:(id)bounds boundsInflation:(float)inflation;
- (struct vector<gm::Matrix<float, 2, 1>, std::allocator<gm::Matrix<float, 2, 1>>> { void * x0; void * x1; struct __compressed_pair<gm::Matrix<float, 2, 1> *, std::allocator<gm::Matrix<float, 2, 1>>> { void * x0; } x2; })maneuverPoints;
- (struct Matrix<double, 4, 4> { double x0[16] })inverseManeuverTransform;
- (struct Matrix<double, 4, 4> { double x0[16] })maneuverTransform;
- (double)boundsUnitsPerMeter;
@end

#endif /* VKRouteLine_h */
