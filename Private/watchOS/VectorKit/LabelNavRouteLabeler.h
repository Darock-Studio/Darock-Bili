//
//   Generated by https://github.com/blacktop/ipsw (Version: 3.1.454, BuildTime: 2024-02-08T22:07:34Z)
//
//    - LC_BUILD_VERSION:  Platform: watchOSSimulator, MinOS: 10.2, SDK: 10.2, Tool: ld (902.8)
//    - LC_SOURCE_VERSION: 1899.42.9.28.10
//
#ifndef LabelNavRouteLabeler_h
#define LabelNavRouteLabeler_h
@import Foundation;

#include "VKLabelNavRoadGraph.h"
#include "VKPolylineOverlay.h"

@class NSMutableArray, NSMutableDictionary, NSMutableSet, NSString;
@protocol {range_map<geo::Unit<geo::RadianUnitDescription, float>, md::OrientationAction, std::less<geo::Unit<geo::RadianUnitDescription, float>>, std::allocator<std::pair<const gm::Range<geo::Unit<geo::RadianUnitDescription, float>>, md::OrientationAction>>>="_storage"{map<gm::Range<geo::Unit<geo::RadianUnitDescription, float>>, md::OrientationAction, geo::range_map<geo::Unit<geo::RadianUnitDescription, float>, md::OrientationAction>::RangeCompare, std::allocator<std::pair<const gm::Range<geo::Unit<geo::RadianUnitDescription, float>>, md::OrientationAction>>>="__tree_"{__tree<std::__value_type<gm::Range<geo::Unit<geo::RadianUnitDescription, float>>, md::OrientationAction>, std::__map_value_compare<gm::Range<geo::Unit<geo::RadianUnitDescription, float>>, std::__value_type<gm::Range<geo::Unit<geo::RadianUnitDescription, float>>, md::OrientationAction>, geo::range_map<geo::Unit<geo::RadianUnitDescription, float>, md::OrientationAction>::RangeCompare>, std::allocator<std::__value_type<gm::Range<geo::Unit<geo::RadianUnitDescription, float>>, md::OrientationAction>>>="__begin_node_"^v"__pair1_"{__compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<gm::Range<geo::Unit<geo::RadianUnitDescription, float>>, md::OrientationAction>, void *>>>="__value_"{__tree_end_node<std::__tree_node_base<void *> *>="__left_"^v}}"__pair3_"{__compressed_pair<unsigned long, std::__map_value_compare<gm::Range<geo::Unit<geo::RadianUnitDescription, float>>, std::__value_type<gm::Range<geo::Unit<geo::RadianUnitDescription, float>>, md::OrientationAction>, geo::range_map<geo::Unit<geo::RadianUnitDescription, float>, md::OrientationAction>::RangeCompare>>="__value_"Q}}}}, {shared_ptr<gss::StylesheetManager<gss::PropertyID>>="__ptr_"^v"__cntrl_"^{__shared_weak_count}}, {shared_ptr<md::NavCurrentRoadSign>="__ptr_"^{NavCurrentRoadSign}"__cntrl_"^{__shared_weak_count}}, {unordered_set<std::shared_ptr<md::LabelTile>, std::hash<std::shared_ptr<md::LabelTile>>, std::equal_to<std::shared_ptr<md::LabelTile>>, geo::StdAllocator<std::shared_ptr<md::LabelTile>, mdm::Allocator>>="__table_"{__hash_table<std::shared_ptr<md::LabelTile>, std::hash<std::shared_ptr<md::LabelTile>>, std::equal_to<std::shared_ptr<md::LabelTile>>, geo::StdAllocator<std::shared_ptr<md::LabelTile>, mdm::Allocator>>="__bucket_list_"{unique_ptr<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> *[], std::__bucket_list_deallocator<geo::StdAllocator<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> *, mdm::Allocator>>>="__ptr_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> **, std::__bucket_list_deallocator<geo::StdAllocator<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> *, mdm::Allocator>>>="__value_"^^v"__value_"{__bucket_list_deallocator<geo::StdAllocator<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> *, mdm::Allocator>>="__data_"{__compressed_pair<unsigned long, geo::StdAllocator<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> *, mdm::Allocator>>="__value_"Q"__value_"{StdAllocator<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> *, mdm::Allocator>="_allocator"^{Allocator}}}}}}"__p1_"{__compressed_pair<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *>, geo::StdAllocator<std::__hash_node<std::shared_ptr<md::LabelTile>, void *>, mdm::Allocator>>="__value_"{__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *>="__next_"^v}"__value_"{StdAllocator<std::__hash_node<std::shared_ptr<md::LabelTile>, void *>, mdm::Allocator>="_allocator"^{Allocator}}}"__p2_"{__compressed_pair<unsigned long, std::hash<std::shared_ptr<md::LabelTile>>>="__value_"Q}"__p3_"{__compressed_pair<float, std::equal_to<std::shared_ptr<md::LabelTile>>>="__value_"f}}}, {vector<md::AvoidanceRectWithPriority, geo::StdAllocator<md::AvoidanceRectWithPriority, mdm::Allocator>>="__begin_"^{AvoidanceRectWithPriority}"__end_"^{AvoidanceRectWithPriority}"__end_cap_"{__compressed_pair<md::AvoidanceRectWithPriority *, geo::StdAllocator<md::AvoidanceRectWithPriority, mdm::Allocator>>="__value_"^{AvoidanceRectWithPriority}"__value_"{StdAllocator<md::AvoidanceRectWithPriority, mdm::Allocator>="_allocator"^{Allocator}}}}, {vector<std::shared_ptr<md::NavLabel>, geo::StdAllocator<std::shared_ptr<md::NavLabel>, mdm::Allocator>>="__begin_"^v"__end_"^v"__end_cap_"{__compressed_pair<std::shared_ptr<md::NavLabel> *, geo::StdAllocator<std::shared_ptr<md::NavLabel>, mdm::Allocator>>="__value_"^v"__value_"{StdAllocator<std::shared_ptr<md::NavLabel>, mdm::Allocator>="_allocator"^{Allocator}}}};

@interface LabelNavRouteLabeler : NSObject {
  /* instance variables */
  BOOL _isOnRoute;
  unsigned long long _stepIndex;
  BOOL _checkOnRouteLabelsAlignment;
  BOOL _disableTileParseForOneLayout;
  struct unordered_set<std::shared_ptr<md::LabelTile>, std::hash<std::shared_ptr<md::LabelTile>>, std::equal_to<std::shared_ptr<md::LabelTile>>, geo::StdAllocator<std::shared_ptr<md::LabelTile>, mdm::Allocator>> { struct __hash_table<std::shared_ptr<md::LabelTile>, std::hash<std::shared_ptr<md::LabelTile>>, std::equal_to<std::shared_ptr<md::LabelTile>>, geo::StdAllocator<std::shared_ptr<md::LabelTile>, mdm::Allocator>> { struct unique_ptr<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> *[], std::__bucket_list_deallocator<geo::StdAllocator<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> *, mdm::Allocator>>> { struct __compressed_pair<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> **, std::__bucket_list_deallocator<geo::StdAllocator<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> *, mdm::Allocator>>> { void * *__value_; struct __bucket_list_deallocator<geo::StdAllocator<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> *, mdm::Allocator>> { struct __compressed_pair<unsigned long, geo::StdAllocator<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> *, mdm::Allocator>> { unsigned long long __value_; struct StdAllocator<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> *, mdm::Allocator> { struct Allocator *_allocator; } __value_; } __data_; } __value_; } __ptr_; } __bucket_list_; struct __compressed_pair<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *>, geo::StdAllocator<std::__hash_node<std::shared_ptr<md::LabelTile>, void *>, mdm::Allocator>> { struct __hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> { void *__next_; } __value_; struct StdAllocator<std::__hash_node<std::shared_ptr<md::LabelTile>, void *>, mdm::Allocator> { struct Allocator *_allocator; } __value_; } __p1_; struct __compressed_pair<unsigned long, std::hash<std::shared_ptr<md::LabelTile>>> { unsigned long long __value_; } __p2_; struct __compressed_pair<float, std::equal_to<std::shared_ptr<md::LabelTile>>> { float __value_; } __p3_; } __table_; } _tiles;
  struct unordered_set<std::shared_ptr<md::LabelTile>, std::hash<std::shared_ptr<md::LabelTile>>, std::equal_to<std::shared_ptr<md::LabelTile>>, geo::StdAllocator<std::shared_ptr<md::LabelTile>, mdm::Allocator>> { struct __hash_table<std::shared_ptr<md::LabelTile>, std::hash<std::shared_ptr<md::LabelTile>>, std::equal_to<std::shared_ptr<md::LabelTile>>, geo::StdAllocator<std::shared_ptr<md::LabelTile>, mdm::Allocator>> { struct unique_ptr<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> *[], std::__bucket_list_deallocator<geo::StdAllocator<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> *, mdm::Allocator>>> { struct __compressed_pair<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> **, std::__bucket_list_deallocator<geo::StdAllocator<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> *, mdm::Allocator>>> { void * *__value_; struct __bucket_list_deallocator<geo::StdAllocator<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> *, mdm::Allocator>> { struct __compressed_pair<unsigned long, geo::StdAllocator<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> *, mdm::Allocator>> { unsigned long long __value_; struct StdAllocator<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> *, mdm::Allocator> { struct Allocator *_allocator; } __value_; } __data_; } __value_; } __ptr_; } __bucket_list_; struct __compressed_pair<std::__hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *>, geo::StdAllocator<std::__hash_node<std::shared_ptr<md::LabelTile>, void *>, mdm::Allocator>> { struct __hash_node_base<std::__hash_node<std::shared_ptr<md::LabelTile>, void *> *> { void *__next_; } __value_; struct StdAllocator<std::__hash_node<std::shared_ptr<md::LabelTile>, void *>, mdm::Allocator> { struct Allocator *_allocator; } __value_; } __p1_; struct __compressed_pair<unsigned long, std::hash<std::shared_ptr<md::LabelTile>>> { unsigned long long __value_; } __p2_; struct __compressed_pair<float, std::equal_to<std::shared_ptr<md::LabelTile>>> { float __value_; } __p3_; } __table_; } _pendingTiles;
  NSMutableArray *_junctions;
  VKLabelNavRoadGraph *_roadGraph;
  NSMutableArray *_fadingLabels;
  NSMutableDictionary *_visibleLabelsByName;
  NSMutableArray *_visibleLabels;
  NSMutableSet *_visibleShieldGroups;
  unsigned long long _countVisibleOnRouteRoadSigns;
  unsigned long long _countVisibleOffRouteRoadSigns;
  unsigned long long _countVisibleRoadSigns;
  unsigned long long _maxVisibleOnRouteRoadSigns;
  unsigned long long _maxVisibleOffRouteRoadSigns;
  unsigned long long _maxVisibleRoadSigns;
  unsigned long long _maxOnRoadGraphRoadSigns;
  unsigned long long _minVisibleOffRoadGraphRoadSigns;
  unsigned long long _minVisibleProceedToRouteRoadSigns;
  BOOL _preferRightSideLabelPlacement;
  float _minSignOffsetDistance;
  NSMutableSet *_roadNamesInGuidance;
  NSMutableArray *_guidanceStepInfos;
  NSMutableArray *_routeRoadInfos;
  long long _currentRoadNameIndex;
  BOOL _checkIfRouteSubrangeChanged;
  BOOL _useRouteSubrange;
  BOOL _regenerateRoadSigns;
  BOOL _isStylesheetAnimating;
  struct PolylineCoordinate { unsigned int index; float offset; } _routeSubrangeStart;
  struct PolylineCoordinate { unsigned int index; float offset; } _routeSubrangeEnd;
  BOOL _isCurrentRoadSignVisible;
  unsigned long long _debugCachedMaxVisibleOffRouteRoadSigns;
  unsigned long long _debugCachedMaxVisibleOnRouteRoadSigns;
  struct shared_ptr<gss::StylesheetManager<gss::PropertyID>> { void *__ptr_; struct __shared_weak_count *__cntrl_; } _styleManager;
  BOOL _shouldLabelOppositeCarriageways;
  struct vector<md::AvoidanceRectWithPriority, geo::StdAllocator<md::AvoidanceRectWithPriority, mdm::Allocator>> { struct AvoidanceRectWithPriority *__begin_; struct AvoidanceRectWithPriority *__end_; struct __compressed_pair<md::AvoidanceRectWithPriority *, geo::StdAllocator<md::AvoidanceRectWithPriority, mdm::Allocator>> { struct AvoidanceRectWithPriority *__value_; struct StdAllocator<md::AvoidanceRectWithPriority, mdm::Allocator> { struct Allocator *_allocator; } __value_; } __end_cap_; } _avoidanceRects;
  BOOL _hasPendingTilesInSnappingRegion;
  BOOL _needsDebugConsoleClear;
  struct range_map<geo::Unit<geo::RadianUnitDescription, float>, md::OrientationAction, std::less<geo::Unit<geo::RadianUnitDescription, float>>, std::allocator<std::pair<const gm::Range<geo::Unit<geo::RadianUnitDescription, float>>, md::OrientationAction>>> { struct map<gm::Range<geo::Unit<geo::RadianUnitDescription, float>>, md::OrientationAction, geo::range_map<geo::Unit<geo::RadianUnitDescription, float>, md::OrientationAction>::RangeCompare, std::allocator<std::pair<const gm::Range<geo::Unit<geo::RadianUnitDescription, float>>, md::OrientationAction>>> { struct __tree<std::__value_type<gm::Range<geo::Unit<geo::RadianUnitDescription, float>>, md::OrientationAction>, std::__map_value_compare<gm::Range<geo::Unit<geo::RadianUnitDescription, float>>, std::__value_type<gm::Range<geo::Unit<geo::RadianUnitDescription, float>>, md::OrientationAction>, geo::range_map<geo::Unit<geo::RadianUnitDescription, float>, md::OrientationAction>::RangeCompare>, std::allocator<std::__value_type<gm::Range<geo::Unit<geo::RadianUnitDescription, float>>, md::OrientationAction>>> { void *__begin_node_; struct __compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<gm::Range<geo::Unit<geo::RadianUnitDescription, float>>, md::OrientationAction>, void *>>> { struct __tree_end_node<std::__tree_node_base<void *> *> { void *__left_; } __value_; } __pair1_; struct __compressed_pair<unsigned long, std::__map_value_compare<gm::Range<geo::Unit<geo::RadianUnitDescription, float>>, std::__value_type<gm::Range<geo::Unit<geo::RadianUnitDescription, float>>, md::OrientationAction>, geo::range_map<geo::Unit<geo::RadianUnitDescription, float>, md::OrientationAction>::RangeCompare>> { unsigned long long __value_; } __pair3_; } __tree_; } _storage; } _leftTurnOrientations;
  struct range_map<geo::Unit<geo::RadianUnitDescription, float>, md::OrientationAction, std::less<geo::Unit<geo::RadianUnitDescription, float>>, std::allocator<std::pair<const gm::Range<geo::Unit<geo::RadianUnitDescription, float>>, md::OrientationAction>>> { struct map<gm::Range<geo::Unit<geo::RadianUnitDescription, float>>, md::OrientationAction, geo::range_map<geo::Unit<geo::RadianUnitDescription, float>, md::OrientationAction>::RangeCompare, std::allocator<std::pair<const gm::Range<geo::Unit<geo::RadianUnitDescription, float>>, md::OrientationAction>>> { struct __tree<std::__value_type<gm::Range<geo::Unit<geo::RadianUnitDescription, float>>, md::OrientationAction>, std::__map_value_compare<gm::Range<geo::Unit<geo::RadianUnitDescription, float>>, std::__value_type<gm::Range<geo::Unit<geo::RadianUnitDescription, float>>, md::OrientationAction>, geo::range_map<geo::Unit<geo::RadianUnitDescription, float>, md::OrientationAction>::RangeCompare>, std::allocator<std::__value_type<gm::Range<geo::Unit<geo::RadianUnitDescription, float>>, md::OrientationAction>>> { void *__begin_node_; struct __compressed_pair<std::__tree_end_node<std::__tree_node_base<void *> *>, std::allocator<std::__tree_node<std::__value_type<gm::Range<geo::Unit<geo::RadianUnitDescription, float>>, md::OrientationAction>, void *>>> { struct __tree_end_node<std::__tree_node_base<void *> *> { void *__left_; } __value_; } __pair1_; struct __compressed_pair<unsigned long, std::__map_value_compare<gm::Range<geo::Unit<geo::RadianUnitDescription, float>>, std::__value_type<gm::Range<geo::Unit<geo::RadianUnitDescription, float>>, md::OrientationAction>, geo::range_map<geo::Unit<geo::RadianUnitDescription, float>, md::OrientationAction>::RangeCompare>> { unsigned long long __value_; } __pair3_; } __tree_; } _storage; } _rightTurnOrientations;
}

@property (nonatomic) BOOL drawRoadSigns;
@property (retain, nonatomic) VKPolylineOverlay *route;
@property (retain, nonatomic) NSString *currentLocationText;
@property (retain, nonatomic) NSString *currentRoadName;
@property (retain, nonatomic) NSString *currentShieldGroup;
@property (nonatomic) struct PolylineCoordinate { unsigned int x0; float x1; } routeUserOffset;
@property (readonly, nonatomic) const void * activeSigns;
@property (readonly, nonatomic) const void * visibleSigns;
@property (readonly, nonatomic) BOOL needsLayout;
@property (readonly, nonatomic) void * currentRoadSign;
@property (readonly, nonatomic) float currentRoadSignPixelHeight;
@property (nonatomic) BOOL debugDisableRoadSignLimit;
@property (nonatomic) BOOL debugEnableShieldsOnRouteLine;
@property (nonatomic) void * artworkCache;

/* instance methods */
- (BOOL)needsDebugDraw;
- (void)debugDraw:(id)draw overlayConsole:(void *)console navContext:(struct NavContext { undefined * * x0; struct LabelManager * x1; struct MapNavLabeler * x2; struct LabelLayoutContext * x3; struct LabelNavLayoutContext * x4; } *)context;
- (void)drawRoadSignOrientationDebugView:(void *)view navContext:(struct NavContext { undefined * * x0; struct LabelManager * x1; struct MapNavLabeler * x2; struct LabelLayoutContext * x3; struct LabelNavLayoutContext * x4; } *)context;
- (void)drawNavOverlayDebugView:(void *)view navContext:(struct NavContext { undefined * * x0; struct LabelManager * x1; struct MapNavLabeler * x2; struct LabelLayoutContext * x3; struct LabelNavLayoutContext * x4; } *)context;
- (id)init;
- (void)setStyleManager:(struct shared_ptr<gss::StylesheetManager<gss::PropertyID>> { void * x0; struct __shared_weak_count * x1; })manager;
- (void)setMaxVisibleRoadsigns:(unsigned int)roadsigns;
- (BOOL)isNavMode;
- (void)clearSceneIsMemoryWarning:(BOOL)warning;
- (void)_reloadRouteJunctions;
- (void)_refreshGuidanceRoadNames;
- (void)grabTilesFromScene:(const void *)scene;
- (void)_tryAddRoadSignForJunction:(id)junction navContext:(struct NavContext { undefined * * x0; struct LabelManager * x1; struct MapNavLabeler * x2; struct LabelLayoutContext * x3; struct LabelNavLayoutContext * x4; } *)context labelCollisionEnabled:(BOOL)enabled;
- (void)_createOrUpdateLabelForRoad:(id)road isShield:(BOOL)shield navContext:(struct NavContext { undefined * * x0; struct LabelManager * x1; struct MapNavLabeler * x2; struct LabelLayoutContext * x3; struct LabelNavLayoutContext * x4; } *)context hopOffsetDistance:(float)distance;
- (void)_tryAddRoadSignForRoad:(id)road isShield:(BOOL)shield navContext:(struct NavContext { undefined * * x0; struct LabelManager * x1; struct MapNavLabeler * x2; struct LabelLayoutContext * x3; struct LabelNavLayoutContext * x4; } *)context labelCollisionEnabled:(BOOL)enabled;
- (void)_tryAddLabel:(id)label navContext:(struct NavContext { undefined * * x0; struct LabelManager * x1; struct MapNavLabeler * x2; struct LabelLayoutContext * x3; struct LabelNavLayoutContext * x4; } *)context labelCollisionEnabled:(BOOL)enabled;
- (BOOL)_collideLabel:(id)label activeLabel:(id)label labelsToRemove:(id)remove;
- (void)styleManagerDidChange:(BOOL)change;
- (void)styleManagerDidStartAnimating;
- (void)styleManagerDidFinishAnimating;
- (void)_generateCurrentRoadSignWithContext:(struct NavContext { undefined * * x0; struct LabelManager * x1; struct MapNavLabeler * x2; struct LabelLayoutContext * x3; struct LabelNavLayoutContext * x4; } *)context;
- (struct RoadSignOrientationResolver { void * x0; struct Unit<geo::RadianUnitDescription, float> { float x0; } x1; unsigned char x2; })createRoadSignOrientationResolver:(id)resolver navContext:(struct NavContext { undefined * * x0; struct LabelManager * x1; struct MapNavLabeler * x2; struct LabelLayoutContext * x3; struct LabelNavLayoutContext * x4; } *)context;
- (unsigned char)resolveOrientation:(struct NavContext { undefined * * x0; struct LabelManager * x1; struct MapNavLabeler * x2; struct LabelLayoutContext * x3; struct LabelNavLayoutContext * x4; } *)orientation road:(id)road currentOrientation:(unsigned char)orientation;
- (unsigned char)orientationForRoadSign:(id)sign roadLabel:(id)label navContext:(struct NavContext { undefined * * x0; struct LabelManager * x1; struct MapNavLabeler * x2; struct LabelLayoutContext * x3; struct LabelNavLayoutContext * x4; } *)context;
- (void)layoutWithNavContext:(struct NavContext { undefined * * x0; struct LabelManager * x1; struct MapNavLabeler * x2; struct LabelLayoutContext * x3; struct LabelNavLayoutContext * x4; } *)context avoidanceRects:(const void *)rects;
- (void)_addVisibleSigns;
- (void)_addLabelsAtJunctions:(id)junctions withContext:(struct NavContext { undefined * * x0; struct LabelManager * x1; struct MapNavLabeler * x2; struct LabelLayoutContext * x3; struct LabelNavLayoutContext * x4; } *)context maxLabelsToAdd:(unsigned long long)add;
- (void)_addLabelsForJunctions:(id)junctions withContext:(struct NavContext { undefined * * x0; struct LabelManager * x1; struct MapNavLabeler * x2; struct LabelLayoutContext * x3; struct LabelNavLayoutContext * x4; } *)context maxLabelsToAdd:(unsigned long long)add useAllJunctions:(BOOL)junctions placeShieldsFrontToBack:(BOOL)back;
- (BOOL)_addJunctionsForTile:(const void *)tile;
- (void)_updateUniqueOffRouteRoads;
- (void)_updateRoadStarts;
- (void)_updateRoadsInGuidance;
- (void)_updatePreferredLabelPlacements;
- (void)_dedupOffRouteRoads;
- (void)_initalizeCurrentRoadInfo;
- (void)_updateCurrentRoadInfo;
- (BOOL)_findRouteOverlappingJunctionFrom:(long long)from routeJunctions:(void *)junctions lookBackward:(BOOL)backward firstOverlap:(long long *)overlap secondOverlap:(long long *)overlap;
- (BOOL)_updateActiveRouteRange;
- (unsigned char)computeRoutePositionForPOIAtPixel:(const void *)pixel currentPosition:(unsigned char)position context:(struct NavContext { undefined * * x0; struct LabelManager * x1; struct MapNavLabeler * x2; struct LabelLayoutContext * x3; struct LabelNavLayoutContext * x4; } *)context;
@end

#endif /* LabelNavRouteLabeler_h */
